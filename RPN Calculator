# The RPN Calculator
import operator # This import assists communication with the program to make the functions work within.

x = 0 # The left number typed in as a value when put in the calculator.
y = 0 # The right number typed in as a value when put in the calculator.
o = operator # This is the outcome for when both numbers are put together

# This serves as the evaluation of the program, which operates multiple forms of addition
def arithmetics(x, y): 
    return x + y # the return is used to both add up and gives out a result.

def rpn_calculation(c): # This helps the function perform the calculation by changing the value within the program, depending on which math operation you are using. 
# known math operators: "+", "-", "*", "/"
    stack = [] # The stack is used to help push the numbers together and to pop them out for the calculator to give out the result.
    
    if c == 0: # if/elif c == 0-3: helps run the code through the operation to give us an addition, subtraction, multiplication, or division within the program.
        stack.append(1)
        stack.append(1)
        y = stack.pop()
        x = stack.pop()
        result = x + y
        stack.append(stack.pop() + stack.pop())
        print(1 + 1)
    # This stack pushes the 1 two times and adds them together, and then gives us a result of 2 from (1+1).
    
    elif c == 1:
        stack.append(1)
        stack.append(1)
        x = stack.pop()
        y = stack.pop()
        result = x - y
        stack.append(stack.pop() - stack.pop()) 
        print(1 - 1)
      # This stack does the opposite; it subtracts rather than adds up, giving us a 0 from (1-1).
      
    elif c == 2:
        stack.append(2)
        stack.append(1)
        x = stack.pop()
        y = stack.pop()
        result = x * y
        stack.append(stack.pop() * stack.pop())
        print(2 * 1)
      # This stack mutiplies the numbers as a double which still gives us a result of 2 from (2*1).
      
    elif c == 3:
        stack.append(2)
        stack.append(1)
        x = stack.pop()
        y = stack.pop()
        result = x / y
        stack.append(stack.pop() / stack.pop())
        print(2 / 1)
     # This stack divides the numbers, showing us a number between the two numbers from the setup of these numbers. This still gives us a 2 from (2/1).
     
    else:
        stack.append(2)
        stack.append(1)
        y = stack.pop()
        x = stack.pop()
        result = x * y
        stack.append(stack.pop() * stack.pop())
        print(2 * 1)

    # From testing the math evaluated expressions from the PDF, I got these results below:
#(5+5 = 10),(1+(-1) = 0),(0-(-1) = 1),(0/5 = 0.0),(4/2 = 2.0),(2*1 = 2),(3*2 = 6)
